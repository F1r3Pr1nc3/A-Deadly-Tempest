namespace = distar
#################################
#
# Anomaly Events
# by Dee Majek
# Tweaked by FirePrince
# For disabled L-Gates (less important)
# distar.2050 - distar.8000
#
#################################

### Empty outcome removed ###
# Randomize L-Cluster outcome on_game_start
event = {
	id = distar.8000
	hide_window = yes
	is_triggered_only = yes
	immediate = {
		random_list = {
			3 = {
				set_global_flag = gray_goo_empire_set
				set_global_flag = dragon_season
			}
			3 = {
				set_global_flag = dragon_season
			}
			7 = {
				set_global_flag = gray_goo_crisis_set
				set_global_flag = active_gray_goo
				set_global_flag = dragon_season
			}
		}
	}
}

##### THE ENIGMATIC CACHE ######
# (vanilla only tweaked for lgate_disabled)
# on_mid_game_pulse
event = {
	id = distar.2050
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_distar = yes
		NOT = {
			any_system = {
				has_star_flag = enigmatic_cache_system
			}
		}
		any_playable_country = {
			is_ai = no
			is_at_war = no
		}
	}
	immediate = {
		# spawn tube by random gateway
		random_system = {
			limit = {
				any_system_megastructure = {
					OR = {
						is_megastructure_type = gateway_ruined
						is_megastructure_type = gateway_restored
						is_megastructure_type = gateway_final
						is_megastructure_type = lgate_base
						is_megastructure_type = lgate_disabled
					}
				}
			}
			star = {
				planet_event = {
					id = distar.20501
				}
			}
		}
	}
}

#################################
#
# Distant Stars Events
# by Miranda van den Brink
#
#################################
####### VOIDSPAWN/HATCHLING EVENTS #######
# Gatekeeper Egg Planet Owner
planet_event = {
	id = distar.5000
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		has_planet_flag = hatchling_egg
		NOR = {
			has_global_flag = hatchling_triggered
			has_planet_flag = hatchling_planet_owner_triggered
			owner = { is_at_war = yes }
		}
	}
	immediate = {
		save_global_event_target_as = hatchling_egg
		planet_event = { id = distar.5010 days = 200 random = 100 }
		set_planet_flag = hatchling_planet_owner_triggered
		remove_planet_flag = space_owner_triggered
	}
}

planet_event = {
	id = distar.50061
	hide_window = yes

	is_triggered_only = yes

	immediate = {
		create_country = {
			name = "NAME_Voidspawn"
			type = guardian_hatchling
			flag = {
				icon = {
					category = "spherical"
					file = "flag_spherical_6.dds"
				}
				background = {
					category = "backgrounds"
					file = "00_solid.dds"
				}
				colors = { "red" "red" "null" "null" }
			}
			effect = {
				if = {
					limit = {
						NOT = { has_modifier = hatchling_power }
					}
					add_modifier = { modifier = hatchling_power days = -1 }
				}
				save_global_event_target_as = hatchling_country
				set_country_flag = hatchling_country
				every_playable_country = {
					establish_communications_no_message = event_target:hatchling_country
				}
				create_fleet = {
					name = "NAME_Voidspawn"
					settings = {
						spawn_debris = no
						is_boss = yes
					}
					effect = {
						set_owner = prev
						if = {
							limit = {
								event_target:hatchling_egg = {
									solar_system = {
										NOT = { has_star_flag = guardians_hatchling_system }
									}
									has_planet_flag = fired_nanobots
								}
							}
							create_ship = {
								name = "NAME_Voidspawn"
								design = "NAME_Nanite_Voidspawn"
							}
							event_target:hatchling_egg = {
								random = {
									chance = 60
									random_country = {
										limit = {
											has_country_flag = fired_nanobots
											has_country_flag = fired_nanobots_on@prev
										}
										prevprev = { set_owner = prev }
										remove_country_flag = fired_nanobots@prev
									}
								}
								remove_planet_flag = fired_nanobots
							}
						} else = {
							create_ship = {
								name = "NAME_Voidspawn"
								design = "NAME_Voidspawn"
								# effect = {  }
							}
						}
						last_created_ship = {
							set_ship_flag = hatchling_ship
							save_global_event_target_as = hatchling
							set_disabled = no
						}

						save_global_event_target_as = hatchling_fleet
						set_location = {
							target = root
							distance = 0
							angle = 90
							direction = in_system
						}
						set_fleet_stance = aggressive
						set_aggro_range_measure_from = self # or return_point
						set_aggro_range = 300
						auto_move_to_planet = {
							target = event_target:new_location
							clear_auto_move_on_arrival = no	# distar.5008 sets a new auto move target
						}
					}
				}
			}
		}
		event_target:voidspawn_spawn = { destroy_ambient_object = this }
	}
}

# Quest (from distar.5009)
country_event = {
	id = distar.5012
	title = distar.5012.name
	desc = distar.5012.desc
	picture = GFX_evt_voidspawn
	show_sound = event_laboratory_sound
	location = event_target:hatchling_egg
	is_triggered_only = yes
	option = {
		name = EXCELLENT
		add_research_option = tech_gargantuan_evolution
		add_tech_progress = {
			tech = tech_gargantuan_evolution
			progress = 0.3
		}
	}
	after = {
		hidden_effect = {
			event_target:hatchling_egg = {
				remove_planet_flag = hatchling_egg
				remove_planet_flag = egg_interrupted
				remove_planet_flag = hatchling_will_trigger
				remove_planet_flag = space_owner_triggered
				remove_planet_flag = hatchling_planet_owner_triggered
			}
			# clear_global_event_target = hatchling_egg
			clear_global_event_target = hatchling
			if = {
				limit = { exists = event_target:hatchling_fleet }
				clear_global_event_target = hatchling_fleet
			}

			event_target:hatchling_country = {
				if = { limit = { num_fleets < 1 }
					destroy_country = yes
					clear_global_event_target = hatchling_country
				}
			}
			remove_global_flag = hatchling_triggered # reenable hatch
		}
	}
}

# All Rifts Removed (on_monthly_pulse)
event = {
	id = distar.5014
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		exists = event_target:hatchling_egg
		event_target:hatchling_egg = {
			has_planet_flag = egg_interrupted
			NOR = {
				has_planet_flag = rifts_removed
				has_deposit = d_egg_cracking
			}
		}
	}
	immediate = {
		event_target:hatchling_egg = {
			switch = {
				trigger = is_planet_class
				pc_savannah = {
					set_planet_entity = {
						entity = pc_savannah
					}
				}
				pc_desert = {
					set_planet_entity = {
						entity = pc_desert
					}
				}
				pc_arid = {
					set_planet_entity = {
						entity = pc_arid
					}
				}				# Vanilla fix!?
				pc_gray_goo = {
					set_planet_entity = {
						entity = pc_gray_goo
					}
				}
				pc_gaia = {
					set_planet_entity = {
						entity = pc_gaia
					}
				}
			}
			if = {
				limit = {
					exists = owner
				}
				owner = {
					country_event = {
						id = distar.5015
					}
				}
			}
			else_if = {
				limit = {
					exists = space_owner
				}
				space_owner = {
					country_event = {
						id = distar.5015
					}
				}
			}
			set_planet_flag = rifts_removed
			remove_modifier = egg_rifts
		}
	}
}

# All Rifts Removed Notification
country_event = {
	id = distar.5015
	title = distar.5014.name
	desc = distar.5014.desc
	picture = GFX_evt_news_room
	show_sound = event_radio_chatter
	location = event_target:hatchling_egg
	is_triggered_only = yes
	option = {
		name = EXCELLENT
	}
	after = {
		hidden_effect = {
			event_target:hatchling_egg = {
				remove_planet_flag = hatchling_egg
				remove_planet_flag = egg_interrupted
				remove_planet_flag = hatchling_will_trigger
				remove_planet_flag = space_owner_triggered
				remove_planet_flag = hatchling_planet_owner_triggered
			}
			# clear_global_event_target = hatchling_egg
			clear_global_event_target = hatchling
			clear_global_event_target = hatchling_fleet
			event_target:hatchling_country = {
				if = { limit = { num_fleets < 1 }
					destroy_country = yes
					clear_global_event_target = hatchling_country
				}
			}
			remove_global_flag = hatchling_triggered
		}
	}
}

# Attempts to create new enigmatic cache at safe location.
country_event = {
	id = distar.5055
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		# Shouldn't trigger if the enigmatic cache country already has an enigmatic cache in rotation.
		NOT = {
			any_owned_ship = {
				has_ship_flag = enigmatic_cache_ship
			}
		}
	}
	immediate = {
		if = {
			limit = {
				any_playable_country = {
					is_ai = no
					is_at_war = no
					NOT = {
						is_hostile = root.owner
					}
					any_owned_planet = {
						NOT = {
							has_planet_flag = has_been_scanned
						}
					}
				}
			}
			closest_system = {
				limit = {
					exists = owner
					owner = {
						is_ai = no
						is_at_war = no
						NOT = {
							is_hostile = root.owner
						}
					}
					any_system_planet = {
						is_colony = yes
						NOT = {
							has_planet_flag = has_been_scanned
						}
					}
				}
				random_system_planet = {
					limit = {
						is_colony = yes
						NOT = {
							has_planet_flag = has_been_scanned
						}
					}
					save_event_target_as = new_location
					solar_system = {
						set_star_flag = enigmatic_cache_system
					}
				}
			}
			create_enigmatic_cache_fleet = yes
		}
		# A gateway
		else_if = {
			limit = {
				any_system = {
					any_system_megastructure = {
						OR = {
							is_megastructure_type = gateway_ruined
							is_megastructure_type = gateway_restored
							is_megastructure_type = gateway_final
							is_megastructure_type = lgate_base
							is_megastructure_type = lgate_disabled
						}
					}
				}
			}
			closest_system = {
				limit = {
					any_system_megastructure = {
						OR = {
							is_megastructure_type = gateway_ruined
							is_megastructure_type = gateway_restored
							is_megastructure_type = gateway_final
							is_megastructure_type = lgate_base
							is_megastructure_type = lgate_disabled
						}
					}
				}
				random_system_megastructure = {
					limit = {
						OR = {
							is_megastructure_type = gateway_ruined
							is_megastructure_type = gateway_restored
							is_megastructure_type = gateway_final
							is_megastructure_type = lgate_base
							is_megastructure_type = lgate_disabled
						}
					}
					save_event_target_as = new_location
					solar_system = {
						set_star_flag = enigmatic_cache_system
					}
				}
			}
			create_enigmatic_cache_fleet = yes
		}
		# A non hostile system without an owner
		else_if = {
			limit = {
				any_system = {
					has_owner = no
					NOR = {
						has_star_flag = guardian
						has_star_flag = hostile_system
					}
				}
			}
			random_system = {
				limit = {
					has_owner = no
					NOR = {
						has_star_flag = guardian
						has_star_flag = hostile_system
					}
				}
				random_system_planet = {
					limit = {
						has_owner = no
					}
					save_event_target_as = new_location
					solar_system = {
						set_star_flag = enigmatic_cache_system
					}
				}
			}
			create_enigmatic_cache_fleet = yes
		}
		else = {
			country_event = {
				id = distar.5055
				days = 500
			}
		}
	}
}

# Abandoned Cluster Found (bit opt. < 3.0)
# Cancel L-project for others (with compensation)
country_event = {
	id = distar.10951
	title = "distar.10951.name"
	desc = "distar.10951.desc"
	picture = GFX_evt_l-gateway
	show_sound = event_activating_unknown_technology
	location = event_target:candidate_gateway
	is_triggered_only = yes

	immediate = {
		if = {
			limit = { NOT = { exists = event_target:lcluster1 } }
			country_event = { id = distar.11000 days = -1 }
		}
		every_playable_country = {
			limit = {
				NOR = { is_same_empire = from has_country_flag = lcluster_opener }
			}
			if = {
				limit = { has_special_project = LCLUSTER_PROJECT }
				country_event = { id = distar.10952 days = 1 }
			} else_if = {
				limit = { has_event_chain = l_cluster_chain }
				country_event = { id = distar.10953 days = 1 }
			} else = {
				country_event = { id = distar.10954 days = 1 }
			}
		}
		observer_event = { id = observer.62 }

	}
	option = {
		name = "distar.10951.a"
	}
}

# Spawn L-Cluster (bit optimized by FirePrince pre 3.0.3)
country_event = {
	id = distar.11000
	hide_window = yes
	is_triggered_only = yes
	fire_only_once = yes

	immediate = {
		set_spawn_system_batch = begin
		# Batch-processes the spawn_system effects between "begin" and "end"
		# So caches are recalculated only once rather than for every system spawned.
		# Can also be used when removing and adding hyperlanes.
		no_scope = {
			# Makes system positions originate from galactic core.
			spawn_system = {
				min_distance >= 550
				max_distance <= 560
				min_orientation_angle = 44
				max_orientation_angle = 46
				initializer = distantstars_init_01
				hyperlane = no
				effect = {
					save_global_event_target_as = lcluster1
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster1 } }
				random_system = {
					limit = { has_star_flag = lcluster1 }
					save_global_event_target_as = lcluster1
				}
			}
			event_target:lcluster1 = {
				spawn_system = {
					min_distance >= 29
					max_distance <= 31
					min_orientation_angle = 24
					max_orientation_angle = 66
					initializer = distantstars_init_02
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster2
					}
				}
				spawn_system = {
					min_distance >= 29
					max_distance <= 31
					min_orientation_angle = 114
					max_orientation_angle = 156
					initializer = distantstars_init_03
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster3
					}
				}
				spawn_system = {
					min_distance >= 30
					max_distance <= 60
					min_orientation_angle = 340
					max_orientation_angle = 20
					initializer = distantstars_init_01b
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster1b
					}
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster2 } }
				random_system = {
					limit = { has_star_flag = lcluster2 }
					save_global_event_target_as = lcluster2
				}
			}
			event_target:lcluster2 = {
				spawn_system = {
					min_distance >= 30
					max_distance <= 60
					min_orientation_angle = 0
					max_orientation_angle = 40
					initializer = distantstars_init_02b
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster2b
					}
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster3 } }
				random_system = {
					limit = { has_star_flag = lcluster3 }
					save_global_event_target_as = lcluster3
				}
			}
			event_target:lcluster3 = {
				spawn_system = {
					min_distance >= 20
					max_distance <= 30
					min_orientation_angle = 24
					max_orientation_angle = 66
					initializer = distantstars_init_04
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster4
				}
				}
				spawn_system = {
					min_distance >= 10
					max_distance <= 50
					min_orientation_angle = 250
					max_orientation_angle = 290
					initializer = distantstars_init_03b
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster3b
					}
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster4 } }
				random_system = {
					limit = { has_star_flag = lcluster4 }
					save_global_event_target_as = lcluster4
				}
			}
			event_target:lcluster4 = {
				spawn_system = {
					min_distance >= 5
					max_distance <= 10
					min_orientation_angle = 250
					max_orientation_angle = 290
					initializer = distantstars_init_05
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster5
						save_global_event_target_as = graygoo_factory_system
					}
				}
				spawn_system = {
					min_distance >= 30
					max_distance <= 60
					min_orientation_angle = 20
					max_orientation_angle = 160
					initializer = distantstars_init_04b
					hyperlane = no
					effect = {
						save_global_event_target_as = lcluster4b
					}
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster5 } }
				random_system = {
					limit = { has_star_flag = lcluster5 }
					save_global_event_target_as = lcluster5
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster1b } }
				random_system = {
					limit = { has_star_flag = lcluster1b }
					save_global_event_target_as = lcluster1b
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster2b } }
				random_system = {
					limit = { has_star_flag = lcluster2b }
					save_global_event_target_as = lcluster2b
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster3b } }
				random_system = {
					limit = { has_star_flag = lcluster3b }
					save_global_event_target_as = lcluster3b
				}
			}
			if = { limit = { NOT = { exists = event_target:lcluster4b } }
				random_system = {
					limit = { has_star_flag = lcluster4b }
					save_global_event_target_as = lcluster4b
				}
			}

			# Mod GUILLI / Crisis Manager support.
			if = {
				limit = {
					OR = {
						has_global_flag = has_guillis_planet_modifiers_mod
						AND = {
							exists = event_target:CmtGlobalVar
							event_target:CmtGlobalVar = { check_variable = { which = CmtVarLgateTerraformNanite value = 6 } }
							NOR = {
								has_global_flag = gray_goo_crisis_set
								has_global_flag = gray_goo_empire_set
							}
						}
					}
				}
				every_system = {
					limit = { has_star_flag = lcluster }
					if = { limit = { has_global_flag = has_guillis_planet_modifiers_mod }
						every_system_planet = {
							planet_event = { id = gpm_engine.1 }
						}
					}
					### Terraformablity
					if = {
						limit = {
							exists = event_target:CmtGlobalVar
							event_target:CmtGlobalVar = { check_variable = { which = CmtVarLgateTerraformNanite value = 6 } }
							NOR = {
								has_global_flag = gray_goo_crisis_set
								has_global_flag = gray_goo_empire_set
							}
						}
						every_system_planet = {
							limit = { is_planet_class = pc_gray_goo }
							add_modifier = { modifier = terraforming_candidate days = -1 }
						}
					}
				}
			} # GUILLI END

			# Add hyperlanes
			event_target:lcluster5 = {
				add_hyperlane = {
					from = this
					to = event_target:lcluster4
				}
				# For backward compat.
				if = { limit = { exists = event_target:lcluster5b }
					add_hyperlane = {
						from = this
						to = event_target:lcluster5b
					}
				}
			}
			event_target:lcluster4 = {
				add_hyperlane = {
					from = this
					to = event_target:lcluster3
				}
				add_hyperlane = {
					from = this
					to = event_target:lcluster2
				}
				add_hyperlane = {
					from = this
					to = event_target:lcluster4b
				}
			}
			event_target:lcluster3 = {
				add_hyperlane = {
					from = this
					to = event_target:lcluster1
				}
				add_hyperlane = {
					from = this
					to = event_target:lcluster3b
				}
			}
			event_target:lcluster2 = {
				add_hyperlane = {
					from = this
					to = event_target:lcluster1
				}
				add_hyperlane = {
					from = this
					to = event_target:lcluster3
				}
				add_hyperlane = {
					from = this
					to = event_target:lcluster2b
				}
			}
			event_target:lcluster1 = {
				add_hyperlane = {
					from = this
					to = event_target:lcluster1b
				}
				# Activate Terminal Egress L-Gate
				random_system_megastructure = {
					limit = { is_megastructure_type = lgate_base }
					activate_gateway = this
					set_megastructure_flag = lgate_activated
				}
				set_star_flag = swarm_invasion_warning
			}
			event_target:lcluster1b = {
				add_hyperlane = {
					from = this
					to = event_target:lcluster2b
				}
			}
		}
		set_spawn_system_batch = end
		set_country_flag = lgates_activated
		if = {
			limit = {
				OR = {
					has_global_flag = dragon_season
					has_global_flag = gray_goo_crisis_set
					# has_global_flag = gray_goo_empire_set
				}
			}
			# Do open all same time!?
			every_megastructure = {
				limit = { CmtTriggerIsClosedLgate = yes }
				CmtEffectOpenLgate = yes
			}
		}
	}
}
